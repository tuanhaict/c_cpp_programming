# OOP

OOP hay còn gọi là lập trình hướng đối tượng, là việc mình đóng gói mọi thứ như biến, hàm vào 1 đối tượng giúp dễ dàng kiểm soát và bảo trì.

Bình thường mình viết code mình sẽ định nghĩa biến rồi các hàm rồi dùng chúng, với OOP, mình đóng gói nó lại vào 1 khối để dễ dàng kiểm soát nó.

Chẳng hạn mình cần viết chương trình lấy vào tên, tuổi của một người và in nó ra màn hình.
Thay vì:
```cpp
void printInfo(string name, int age)
{
    cout << "Name: " << name << "Age: " << age;
}
int main()
{
    string name;
    int age;
    cin >> name;
    cin >> age;
    while (age < 0) 
    {
        cout << "Please enter a valid age";
        cin >> age;
    } 
    printInfo(name, age);
}
```

Chúng ta đóng gói những thứ liên quan đến nhau vào 1 khối gọi là class, vì tên, tuổi đều thuộc 1 người, ta tạo ra kiểu dữ liệu mới Person chứa tên và tuổi, cũng như hàm in ra tên, tuổi.

```cpp
class Person {
    string name;
    int age;
    void printInfo(string name, int age) 
    {
        cout << "Name: " << name << "Age: " << age;
    }
};
```
## 1. Class và object
- Class khá giống struct, dùng tạo ra 1 kiểu dữ liệu bao gồm những kiểu dữ liệu khác.
- Khác với struct, class có thể định nghĩa hàm thuộc về nó và có thêm các tính chất để giúp code dễ dàng tái sử dụng, phù hợp cho OOP.
- Ví dụ:
```cpp
class Person {
    string name;
    int age;
    void setAge(int a) {
        if(a > 0) age = a;
    }
    int getAge() {
        return age;
    }
};
```
- **Object (đối tượng)**: là biến mang kiểu dữ liệu là class.
- **Biến thành viên**: Là các biến nằm trong class đó, ở ví dụ trên là `name`, `age`, mô tả những thuộc tính của đối tượng.
- **Hàm thành viên (phương thức)**: Là các hàm nằm trong class đó, mô tả những hành vi mà đối tượng có thể làm.

## 2. Hàm tạo và hàm hủy.

### 2.1. Hàm tạo (constructor)

- Là hàm để tạo đối tượng, có thể thêm các giá trị khởi tạo cho đối tượng.
- Có cùng tên với class, 1 class có thể có nhiều hàm tạo.
- Ví dụ:
```cpp
class Person {
    string name;
    int age;
public:
    Person() {} // tự động tạo
    Person(string a) {
        name = a;
    }
    Person(int b) {
        age = b;
    }
    Person(string a, int b) {
        name = a;
        age = b;
    }
    //hoặc có thể viết là
    Person(string a) : name(a) {}
    Person(int b) : age(b) {}
    Person(string a, int b): name(a), age(b) {}
};

int main()
{
    Person a; // khởi tạo nhưng mà không gán tên tuổi
    Person b("Linh"); // khởi tạo tên cho b
    Person c(20); // khởi tạo tuổi cho c
    Person d("Tuan", 22); // khởi tạo tuổi cho d
    Person* a = new Person(); // dùng toán tử new để tạo đối tượng
    Person* b = new Person("Linh");
    Person* c = new Person(20);
}
```

### 2.2 Hàm hủy (destructor)
- Là hàm được chạy khi tự động khi đối tượng không dùng nữa, dùng để giải phóng các vùng nhớ đã cập hay dọn dẹp file.
- Có tên `~<tên class>`, ví dụ: `~Person()`, mỗi class chỉ có 1 hàm hủy.
```cpp
#include <iostream>
using namespace std;
class Person
{
    string name;
    int age;
    int *coursesId;

public:
    Person() {} // tự động tạo

    Person(int numCourses)
    {
        this->coursesId = new int[numCourses];
    }

    ~Person()
    {
        cout << "Huy";
        delete[] this->coursesId;
    }
};
void function()
{
    Person b(5); // khởi tạo và cấp phát mảng coursesId
}
int main()
{
    Person *a = new Person(); // khởi tạo nhưng mà không gán tên tuổi
    function();
    delete a;
    return 0;
}
```
## 3. Nạp chồng toán tử.

- Các toán tử như `+,-,*,/,...` hoạt động với các kiểu dữ liệu như `int, float,...` bởi vì người ta đã định nghĩa cách tính trên các dữ liệu đó.
- Vậy có các nào để ta `+,-,*,...` các đối tượng không. Đó là `nạp chồng toán tử`.
- Ví dụ:
```cpp
class Vector2D {
public:
    int x, y;
    Vector2D(int a, int b) : x(a), y(b) {}

    // Nạp chồng toán tử +
    Vector2D operator + (const Vector2D& v) {
        return Vector2D(x + v.x, y + v.y);
    }

    // Nạp chồng toán tử -
    Vector2D operator - (const Vector2D& v) {
        return Vector2D(x - v.x, y - v.y);
    }
};

int main() {
    Vector2D a(1, 2), b(3, 4);
    Vector2D c(a.x + b.x, a.y + b.y); // daif dongf
    Vector2D c = a + b; // dùng toán tử + tự định nghĩa
    Vector2D d = a - b; 

    cout << c.x << ", " << c.y;  // Kết quả: 4, 6
}
```


## Các tính chất của OOP

### 1.1 Tính đóng gói

- **Định nghĩa**: Là cơ chế gom nhóm dữ liệu (thuộc tính) và các phương thức (hành vi) xử lý dữ liệu đó vào cùng một khối – gọi là lớp.
- **Ý nghĩa**: 
    + Che giấu thông tin: chỉ cho phép truy cập dữ liệu cần thiết.
    + Bảo vệ dữ liệu khỏi bị thay đổi ngoài ý muốn.
- Trong C++, dùng các từ khóa `public`, `private`, `protect` để kiểm soát truy cập.
- Các mức độ truy cập: `public > protected > private`.
- Ví dụ:
```c
class Person {
private: // chỉ có thể truy cập ở trong lớp
    string name;
    int age;

public: // có thể truy cập lẫn trong và ngoài lớp
    void setAge(int a) {
        if(a > 0) age = a;
    }
    int getAge() {
        return age;
    }
};
protected: // chỉ có class này và class con của nó được truy cập.
    void printInfo()
    {
        cout << name << age;
    }
```
### 1.2 Tính trừu tượng

- **Định nghĩa**: Là quá trình ẩn đi các chi tiết không cần thiết và chỉ hiển thị những gì quan trọng với người dùng.

### 1.3 Tính kế thừa

- **Định nghĩa**: Một lớp có thể kế thừa thuộc tính và phương thức từ một lớp khác.
- Ví dụ:
```cpp
class Animal { // lớp cha hay là lớp cơ sở.
public:
    void eat() {
        cout << "Animal eats food" << endl;
    }
protected:
    int size;
};
class Dog : public Animal { //lớp con
public:
    void bark() {
        cout << "Dog barks!" << endl;
    }

};

int main()
{
    Dog* d = new Dog();
    d->bark();
    d->eat();
    return 0;
}
```
- Các kiểu kế thừa: 
    + `public`: Giữ nguyên quyền truy cập ở class cha
    + `protected`: Biến những gì có mức truy cập >= protected thành protected.
    + `private`: Biến tất cả thành private.

### 1.4. Tính đa hình

- **Định nghĩa**: Cùng 1 hàm nhưng lại chạy theo nhiều kiểu khác nhau.
- **Đa hình tĩnh**: Là nạp chồng hàm, cùng 1 tên nhưng có nhiều tham số.
- **Đa hình động**: Dùng hàm ảo và con trỏ lớp cơ sở.

## 5. Hàm ảo

- Cho ví dụ sau:

```cpp
class Animal {
public:
    void sound() {  // Không có virtual
        cout << "Animal sound!" << endl;
    }
};

class Dog : public Animal {
public:
    void sound() {
        cout << "Woof!" << endl;
    }
};
int main() {
    Animal* a = new Dog();
    a->sound();  // In ra: Animal sound! ❌ Không đúng ý!
    delete a;
}
```
- Ta muốn định nghĩa lại 1 hàm nào đó cho lớp con, chẳng hạn như lớp cha thì hàm đó sẽ thực hiện 1 hành động chung chung, nhưng khi lớp con thực hiện thì phải cụ thể.

- Dùng hàm ảo để thực hiện điều này:
```cpp
class Animal {
public:
    virtual void sound() {   // đánh dấu là hàm ảo, có thể ghi đè nó
        cout << "Animal sound!" << endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {  // ghi đè phương thức của lớp cha
        cout << "Woof!" << endl;
    }
};

int main() {
    Animal* a = new Dog();
    a->sound();  // In ra: Woof! ✔ Đúng hành vi
    // Nếu không ghi đè phương thức lớp cha thì sẽ in ra "Animal sound!"
    delete a;
}
```
## 6. Lớp trừu tượng (Abstract class)

- Nếu như hàm ảo không yêu cầu lớp con phải ghi đè, có thể hoặc không
- Thì hàm thuần ảo yêu cầu lớp con phải ghi đè nó, nếu không sẽ bị lỗi.
- Cú pháp: `virtual <tên hàm>() = 0;` (tức là không định nghĩa hàm mà cho nó = 0)
- **Lớp trừu tượng**:
    + Là lớp có chứa ít nhất 1 hàm thuần ảo
    + Không thể tạo ra đối tượng thuộc lớp này
    + Dùng để tạo ra lớp cơ sở cho các đối tượng khác.
```cpp
class Shape {
public:
    virtual double area() = 0;
    virtual ~Shape() {}        
};

class Rectangle : public Shape {
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    double area() override { return width * height; }
};

class Circle : public Shape {
    double radius;
public:
    Circle(double r) : radius(r) {}
    double area() override { return 3.14 * radius * radius; }
};

int main() {
    Shape* s1 = new Rectangle(4, 5);
    Shape* s2 = new Circle(3);
    cout << s1->area() << endl;  // In: 20
    cout << s2->area() << endl;  // In: 28.26
    delete s1;
    delete s2;
}

```

## 7. Hàm bạn

- Một class với các biến, hàm `private`, `protected` sẽ không thể truy cập từ bên ngoài.
- Đôi khi 1 class cũng mong muốn cho phép 1 hàm bên ngoài thỏa mãn những tính chất nào đấy có thể truy cập được `private`, `protected` của mình.
- Để làm được điều đó, cần dùng hàm bạn.
- Class nêu ra cấu trúc hàm bạn và dùng từ khóa `friend`, hàm bên ngoài phải implement đúng tên đó và truyền vào đúng dạng tham số.

```cpp
#include <iostream>
using namespace std;

class Box {
private:
    int width;
    int height;

public:
    Box(int w, int h) : width(w), height(h) {}

    // Khai báo hàm friend
    friend void showBox(Box b);
};

// Định nghĩa hàm friend
void showBox(Box b) {
    cout << "Width: " << b.width << ", Height: " << b.height << endl;
}

int main() {
    Box box(10, 20);
    showBox(box); // OK: có thể truy cập width, height
    return 0;
}
```